var datapoints = [];
var traces = [];
window.addEventListener('load',()=>{

    var datasets = [XP,XN, YP,YN, ZP,ZN];
    var datasetNames = ["XP", "XN", "YP", "YN", "ZP", "ZN"];

    
    //Add offsets to pos values & accumulate positions for each point
    //Then, Add each point & respective distance measurements to datapoints {X,Y,Z, data:{}}
    var pushed0=false;  //Only push one 0 value
    datasets.forEach((set,setid)=>{
        set.X = [];
        set.Y = [];
        set.Z = [];
        var dataKeys = Object.keys(set.data);
        for(var i=0; i<set.pos[0].length; i++){

            set.X[i] = 0;
            set.Y[i] = 0;
            set.Z[i] = 0;

            for(var j=0; j<set.pos.length; j++){
                set[set.axis][i] += set.pos[j][i] - set.off[j][i];
            }
            set[set.axis][i] /=set.pos.length;
            if(set.neg) set[set.axis][i] = - set[set.axis][i];
            if(i!=0) set[set.axis][i]+=set[set.axis][i-1];

            var datapoint = {X:set.X[i], Y:set.Y[i], Z:set.Z[i], data:{}};
            dataKeys.forEach(dkey=>{
                datapoint.data[dkey] = set.data[dkey][i];
            });

            if(datapoint.X == 0 && datapoint.Y==0 && datapoint.Z==0){
                if(pushed0){
                    datapoints.push(datapoint);
                    pushed0=true;
                }
            } else {
                datapoints.push(datapoint);
            }
        }

        /*
        var ntrace = traceTemplate_markers();
        ntrace['x'] = set.X;
        ntrace['y'] = set.Y;
        ntrace['z'] = set.Z;
        ntrace.name = datasetNames[setid];
        traces.push(ntrace);
        */

    });


    var target = "znT7";

    var keys = Object.keys(datapoints[0].data);
    var points = [];
    var ntrace = traceTemplate_markers();
    ntrace.text = [];
    ntrace.name = `calculated ${target}`;
    keys.forEach(key=>{
        if(key.includes(target)){ //only care about xp-space
            console.log(`Processing ${key}`);
            var refs=[];
            datapoints.forEach(dp=>{
                //if(Math.abs(dp.X+dp.Y+dp.Z)>3000){
                    refs.push({
                        x:dp.X,
                        y:dp.Y,
                        z:dp.Z,
                        m:999999-dp.data[key]
                    });
                //}
            });
            var point = ISANv2(refs);
            points.push(point);
            
            ntrace.x.push(point[1]);
            ntrace.y.push(point[2]);
            ntrace.z.push(point[3]);
            ntrace.text.push(`${key} error: ${absSum(get_error([points[0][1], points[0][2], points[0][3]],target))}`);
        }
    });
    traces.push(ntrace);

    var pt = [points[0][1], points[0][2], points[0][3]];

    var minerr=absSum(get_error(pt,target));
    console.log(`${target} error: `, minerr);

    var gdpts = [];
    gdpts.push(doGradientDescent(pt, target));
    var graph = true;
    for(var offs=0; offs<=20; offs+=10){
        gdpts.push(doGradientDescent([pt[0]+offs, pt[1], pt[2]], target,graph));
        gdpts.push(doGradientDescent([pt[0]-offs, pt[1], pt[2]], target,graph));

        gdpts.push(doGradientDescent([pt[0], pt[1]+offs, pt[2]], target,graph));
        gdpts.push(doGradientDescent([pt[0], pt[1]-offs, pt[2]], target,graph));

        gdpts.push(doGradientDescent([pt[0], pt[1], pt[2]+offs], target,graph));
        gdpts.push(doGradientDescent([pt[0]+offs, pt[1]+offs, pt[2]+offs], target,graph));
        gdpts.push(doGradientDescent([pt[0]-offs, pt[1]-offs, pt[2]-offs], target,graph));
    }

    /*
    var gdpts2=[];

    gdpts.forEach(gdp=>{
        gdpts2.push(doGradientDescent(gdp, target));
    });
    */
    var bestpt, err;
    var minerr=100000000000;
    gdpts.forEach(gdp=>{
        err = absSum(get_error(gdp, target));
        if(err<minerr){
            minerr=err;
            bestpt=[...gdp];
        }
    });
    
    ntrace = traceTemplate_markers();
    ntrace.name = `final ${target} gdp`;
    ntrace.text = [`Final ${target}, err: ${err}`];
    ntrace.x[0] = bestpt[0];
    ntrace.y[0] = bestpt[1];
    ntrace.z[0] = bestpt[2];
    traces.push(ntrace);

    console.log(`Final ${target}, err: ${err}, [${bestpt}]`);
    



    /*
    var avg=[0,0,0,0];
    points.forEach(p=>{
        p.forEach((a,i)=>{
            avg[i]+=a;
        });
    });

    for(var i=0; i<avg.length; i++){
        avg[i]/=points.length;
    }

    var ntrace = traceTemplate_markers();
    ntrace.x[0] = avg[1];
    ntrace.y[0] = avg[2];
    ntrace.z[0] = avg[3];
    ntrace.name = `${target} average`;
    traces.push(ntrace);

    var max = [...avg];
    var min = [...avg];
    for(var i=0; i<points.length; i++){
        for(var j=0; j<avg.length; j++){
            if(points[i][j]>max[j]){
                max[j] = points[i][j];
            }
            if(points[i][j]<min[j]){
                min[j] = points[i][j];
            }
        }
    }

    var ntrace = traceTemplate_markers();
    ntrace.x = [min[1],max[1]];
    ntrace.y = [min[2],max[2]];
    ntrace.z = [min[3],max[3]];
    ntrace.text=["min","max"];
    ntrace.name = `${target} min max`;
    traces.push(ntrace);
    */

    



    /*
    var ntrace = traceTemplate_markers();
    datapoints.forEach(datapoint=>{
        ntrace.x.push(datapoint.X);
        ntrace.y.push(datapoint.Y);
        ntrace.z.push(datapoint.Z);
    });
    
    ntrace.name = "datapoints";
    traces.push(ntrace);
    */

    /*
    var ntrace = traceTemplate_markers();
    ntrace.x[0] = 0;
    ntrace.y[0] = 0;
    ntrace.z[0] = 0;
    ntrace.name = `origin`;
    traces.push(ntrace);
    */

    var layout = {margin: {
        l: 0,
        r: 0,
        b: 0,
        t: 0
    }};

    Plotly.newPlot('chart', traces, layout,{editable: true});
    

    //test isanv2
    /*
    var refs = [
        {x:0,y:1,z:2},
        {x:1,y:0,z:0},
        {x:0,y:1,z:0},
        {x:0,y:0,z:1}
    ];

    refs.forEach(ref=>{
        ref["m"] = Math.sqrt(Math.pow(ref.x-10,2)+Math.pow(ref.y-11,2)+Math.pow(ref.z-12,2));
    });

    ISANv2(refs);
    */

});


function doGradientDescent(pt, target, graph = true){
    ntrace = traceTemplate_markers();
    ntrace.mode='lines';
    ntrace.name="gradient descent";

    var curpt = [...pt];
    var laspt = [...pt];
    var step = 5;
    var samples = 10;
    var gettingBetter, err=absSum(get_error(curpt,target));
    var numReduce = 0;
    ntrace.x.push(curpt[0]);
    ntrace.y.push(curpt[1]);
    ntrace.z.push(curpt[2]);
    ntrace.text=["init"];
    do{
        gettingBetter = false;
        //console.log(`Min error is at: ${err}, step: ${step}`);
        var minpt=[];
        var cerr = err;
        for(var itheta=0; itheta<samples; itheta++){
            for(var iphi=0; iphi<samples; iphi++){
                var tsp = [...curpt];
                tsp[0] += step*Math.sin(Math.PI*itheta/samples)*Math.cos(Math.PI*2*iphi/samples);
                tsp[1] += step*Math.sin(Math.PI*itheta/samples)*Math.sin(Math.PI*2*iphi/samples);
                tsp[2] += step*Math.cos(Math.PI*itheta/samples);

                var nerr = absSum(get_error(tsp,target));
                if(nerr<cerr){
                    cerr = nerr;
                    minpt = [...tsp];
                }
            }
        }

        if(cerr<err){
            err=cerr;
            curpt=[...minpt];
            gettingBetter=true;
            ntrace.x.push(curpt[0]);
            ntrace.y.push(curpt[1]);
            ntrace.z.push(curpt[2]);
            ntrace.text.push(`err: ${err}, step: ${step}`);
        } 

        //gettingBetter = !(laspt[0]==curpt[0] && laspt[1]==curpt[1] && laspt[1]==curpt[1])
        //laspt=[...curpt];

        if(gettingBetter==false && numReduce<100){
            gettingBetter=true;
            step/=2;

            numReduce++;
        }

    }while(gettingBetter);

    if(graph)traces.push(ntrace);
    //console.log("gdf: ", curpt);
    /*
    ntrace = traceTemplate_markers();
    ntrace.name = `final ${target}`;
    ntrace.x[0] = curpt[0];
    ntrace.y[0] = curpt[1];
    ntrace.z[0] = curpt[2];
    traces.push(ntrace);*/

    return curpt;
}


function traceTemplate_markers(){
    return {
        x: [], 
        y: [], 
        z: [],
        mode: 'markers',
        marker: {
            size: 10,
            line: {
                color: 'rgba(217, 217, 217, 0.14)',
                width: 0.5
            },
            opacity: 0.8
        },
        type: 'scatter3d'
    }
}

/*Expects references = [
    {x,y,z, m},
    {x,y,z, m}
]
*/
function ISANv2(references){
    var A = [];
    var B = [];

    //Build A&B from references
    references.forEach(r=>{
        A.push(
            [1, -2*r.x, -2*r.y, -2*r.z]
        );
        B.push(
            Math.pow(r.m,2) - Math.pow(r.x,2) - Math.pow(r.y,2) - Math.pow(r.z,2)
        );
    });

    //from cpp
    ////nieve solution   (for exactly 4 references)
    ////x = inv(A) . b
    ////cout<<"nieve x: \n";
    ////vector<double> pos = mult(inv(A),b);

    ////least squares solution
    ////x = inv(trans(A) . A) . trans(A) . b

    m = math.multiply;
    t = math.transpose;
    i = math.inv;

    x  =  m(i(m(t(A),A)) , m(t(A),B));
    //console.log(x);
    return x;   //[agree, x, y, z]
}

//Expects a point [x,y,z] & space-transmitter id (eg, "xpT0")
function get_error(point, S_T_id){
    var err = [];
    datapoints.forEach(dp=>{
        err.push(
            (999999-dp.data[S_T_id]) - 
            Math.floor(1000*Math.sqrt(Math.pow(point[0]-dp.X,2)+Math.pow(point[1]-dp.Y,2)+Math.pow(point[2]-dp.Z,2)))/1000
        );
    });
    return err;
}

function absSum(arr){
    var s = 0;
    arr.forEach(a=>{
        s+=Math.pow(a,2);
    });
    return s;
}