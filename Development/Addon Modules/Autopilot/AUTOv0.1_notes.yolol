
//ISAN inputs
// :X, :Y, :Z

//a b c d e f g h i j k l m n o p q r s t u v w x y z

//Ship direction: (dir)  [x, y, z] //Point B - Point A
//Destination:    (dest) [m, n, o] //Dest - Point A        (in real space)
//Destination:    (dest) [u, v, w] (ship orn space)
//Up:                    [a, b, c]
x=0 y=0 z=0 i=5 div=0
x-=:X y-=:Y z-=:Z div++ goto LINE+(i--==0)  //accumulate i samples & negate 
j=10 i=5 m=:DX-x/5 n=:DY-y/5 o=:DZ-z/5      //setup wait/iter & get dest
goto LINE+(j--==0)  //Wait some number of ticks
x+=:X y+=:Y z+=:Z div++ goto LINE+(i--==0)  //accumulate i samples
//x/=2*i y/=2*i z/=2*i                        //divide to get average (??)

v=sqrt(x^2+y^2+z^2) x/=v y/=v z/=v          //normalise dir
v=sqrt(m^2+n^2+o^2) m/=v n/=v o/=v          //normalise dest


//transform matrix
//      * (left)
//  dir |  up
//   X  Y  Z
// [ x  ?  a ]         = \begin{pmatrix}x&yc-zb&a\\ y&za-xc&b\\ z&xb-ya&c\end{pmatrix}
// [ y  ?  b ] = T     //SO basis vectors in RS coords
// [ z  ?  c ]          T . (SO vector) = (real vector)
// 
//    Transform    . dest(ship orientated) = dest(real)
// [ x  yc-zb  a ]   [ ? ]   [ m ]
// [ y  za-xc  b ]   [ ? ] = [ n ]
// [ z  xb-ya  c ]   [ ? ]   [ o ]
//
// Need to find inverse of T
//  Need to find cofactor of T
//            [ x  yc-zb  a ]   [  (za-xc)c-b(xb-ya)  -yc+bz   y(xb-ya)-(za-xc)z ]
//     cofact [ y  za-xc  b ] = [ -(yc-zb)c+a(xb-ya)   xc-az  -x(xb-ya)+(yc-zb)z ]
//            [ z  xb-ya  c ]   [  (yc-zb)b-a(za-xc)  -xb+ay   x(za-xc)-(yc-zb)y ]
//
//  Need to find determinant of T
//    det(T) = -c^2x^2 -b^2x^2 +2baxy +2caxz -c^2y^2 -a^2y^2 -b^2z^2 -a^2z^2 +2cbyz
//
// divide cofactor by div
// transpose
//
//    
// [ a  b  c ]T  [ m ]   [ am+dn+go ]
// [ d  e  f ]   [ n ] = [ bm+en+ho ]
// [ g  h  i ]   [ o ]   [ cm+fn+io ]
//
// [          ]T  [ m ]   [ ((za-xc)c-b(xb-ya))m + (-(yc-zb)c+a(xb-ya))n + ((yc-zb)b-a(za-xc))o ]
// [ cofactor ]   [ n ] = [ (-yc+bz)m + (xc-az)n + (-xb+ay)o ]
// [          ]   [ o ]   [ (y(xb-ya)-(za-xc)z)m + (-x(xb-ya)+(yc-zb)z)n + (x(za-xc)-(yc-zb)y)o ]
// NB: still to divide by div
//div
// Now have dest vector in ship oriented space
u=((z*a-x*c)*c-b*(x*b-y*a))*m+(a*(x*b-y*a)-(y*c-z*b)*c)*n+((y*c-z*b)*b-a*(z*a-x*c))*o
v=(b*z-y*c)*m+(x*c-a*z)*n+(a*y-x*b)*o
w=(y*(x*b-y*a)-(z*a-x*c)*z)*m+((y*c-z*b)*z-x*(x*b-y*a))*n+(x*(z*a-x*c)-(y*c-z*b)*y)*o

//since direction vector is along X:
//  Y component (v) tells us how much yaw left (but gets small when behind) (x in orn) [-x?]
//  Z component (w) tells us how much pitch up (but gets small when behind) (y in orn)
//
// could fix the getting small issue if space allows

// could make a module to render dest vector on ORN plane

//Need to compare current dest position on ORN vs old dest position on ORN

du=u-lu
dv=v-lv
dw=w-lw

//angle of (last dest -> dest) from x axis (Y+)
//err=180-atan(x/y)-(y<0)*360
err=180-atan(dv/dw)-(dw<0)*360

//store last vars, done using both now
lu=u lv=v lw=w

//if last tried Y+, then
//correction=err
//if last tried Y-, then
//correction=err-180
//if last tried P+, then
//correction=err-90
//if last tried P-, then
//correction=err+90

correction=err-(ly<0)*180-(lp>0)*90+(lp<0)*90


//do correction
// rotate up vector by "correction" degrees around direction vector
c=cos(theta)
s=sin(theta)
m=1-c

//[ c+x*x*m    x*y*m-z*s  x*z*m+y*s ]  [ a ]   [ a' ]
//[ y*x*m+z*s  c+y*y*m    y*z*m-x*s ]  [ b ] = [ b' ]
//[ z*x*m-y*s  z*y*m+x*s  c+z*z*m   ]  [ c ]   [ c' ]

at = (c+x*x*m)*a + (x*y*m-z*s)*b + (x*z*m+y*s)*c
bt = (y*x*m+z*s)*a + (c+y*y*m)*b + (y*z*m-x*s)*c
ct = (z*x*m-y*s)*a + (z*y*m+x*s)*b + (c+z*z*m)*c
a=at b=bt c=ct

//Now need to actually thrust in a given direction
//  TODO proper flight controll & auto calibration
//pick most nessesary move & do it
i=10 ly=0 lp=0  //thrust output & reset last values
if v>w then ly=i-2*i*(v<0) :yaw=ly else lp=i-2*i*(w<0) :pitch=lp end
 

